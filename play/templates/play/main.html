{% extends 'play/base.html' %}

{% block css %}
  <style>
    .w-100px {width:100px;}
    .ratio-1 {aspect-ratio:1;}
  </style>
{% endblock css %}

{% block content %}
  <div id="canvas" class="user-select-none position-relative" style="height:calc(100vh - 200px);font-size:0;"></div>

  <div id="vue-app"></div>
{% endblock content %}

{% block js_libs %}
  {{ block.super }}
  <script src="/static/js/vue3311.global.min.js"></script>
{% endblock js_libs %}

{% block js %}
  <!-- KEYBOARD -->
  <script>
    function keyboard(code) {
      const key = {}
      key.code = code
      key.isDown = false
      key.isUp = true
      key.press = undefined
      key.release = undefined
      //The `downHandler`
      key.downHandler = (event) => {
        if (event.code === key.code) {
          if (key.isUp && key.press) {
            key.press()
          }
          key.isDown = true
          key.isUp = false
          event.preventDefault()
        }
      }

      //The `upHandler`
      key.upHandler = (event) => {
        if (event.code === key.code) {
          if (key.isDown && key.release) {
            key.release()
          }
          key.isDown = false
          key.isUp = true
          event.preventDefault()
        }
      }

      //Attach event listeners
      const downListener = key.downHandler.bind(key)
      const upListener = key.upHandler.bind(key)

      const subscribe = () => {
        window.addEventListener("keydown", downListener, false)
        window.addEventListener("keyup", upListener, false)
      }
      subscribe()

      key.subscribe = subscribe

      // Detach event listeners
      key.unsubscribe = () => {
        window.removeEventListener("keydown", downListener)
        window.removeEventListener("keyup", upListener)
      }

      return key
    }
  </script>

  <!-- UTILS -->
  <script>
    const on = (obj, event, f) => {
      obj.addEventListener(event, f)
    }
    const onLoad = (f) => {
      on(document, 'DOMContentLoaded', f)
    }
    const deg2rad = Math.PI/180
    const rot_x = (x, a) => {
      a = a * deg2rad
      return [Math.cos(a)*x, Math.sin(a)*x]
    }
    const scalar = (a,b) => a.x * b.x + a.y * b.y
    const radBetween = (a,b) => Math.acos(scalar(a,b) / (Math.hypot(a.x, a.y) * Math.hypot(b.x, b.y)))
    const angleBetween = (a,b) => radBetween(a,b) / deg2rad
    const proj = (v, u) => {
      // u - unit vector ||u|| = 1
      const scal = v.x * u.x + v.y * u.y
      const vlen = Math.hypot(v.x, v.y)
      const s = Math.cos(Math.acos(scal / vlen)) * vlen

      return {x: u.x * s, y: u.y * s, length: s}
    }
    const rotate_point = (v, a) => {
      const cos = Math.cos(a)
      const sin = Math.sin(a)

    }
  </script>

  <!-- PIXI -->
  <script>
    const mm2px = 300 / 25.4
    const PAGE_W = 450 * mm2px
    const PAGE_H = 305 * mm2px

    const c_x = PAGE_W / 2
    const c_y = PAGE_H / 2

    const doc_lays = [
      //{id:1, n:'sp1', t:'s', s:.1, src:'/media/ports/img.jpg', x:500, y:50, v:true},
      //{id:2, n:'png_mask', t:'s', s:.5, src:'/media/png_mask.png', x:250, y:50, v:true},
      //{id:3, n:'sp2', t:'s', s:.08, src:'/media/ports/img.jpg', x:50, y:400, v:true},
      //{id:4, n:'img', t:'r', w:60, h:120, col:0xff0000, x:50, y:60, v:true},

      // COLL
      /*
      {id:5, n:'SH', t:'t', x:4295.698914299524, y:262.65131774668953, text:'Школа № 18', v:true, textStyle: {
        // Font
        fontFamily: 'Monotype Corsiva',  // default: Arial
        fontSize: 225,
        fontStyle: "normal",
        fontWeight: "bold",

        // Fill
        fill: "#600005",

        // Multiline
        align: "left",
        lineHeight: 60,
        whiteSpace: "normal",
        //wordWrap: true,
        //wordWrapWidth: 440,

        // Stroke
        stroke: "#bbbd51",
        strokeThickness: 0,
        lineJoin: "round",
        miterLimit: 2,

        // Shadow
        dropShadowColor: '#000000',
        dropShadow: true,
        dropShadowAngle: Math.PI / 2,  // 90 deg down
        dropShadowAlpha: 0.7,
        dropShadowBlur: 10,
        dropShadowDistance: 5,

        // Layout
        letterSpacing: 0,
        textBaseline: "bottom",

        // Texture
        padding: 50,
        trim: true,
      }},

      {id:12, n:'B_TRG', t:'s', s:1, v:true, x:1432.740460449504, y:1016.570321601884, src:'/media/ports/coll_b_trg.png'},
      {id:11, n:'B_deco', t:'s', s:1, v:true, x:1522.7106196508719, y:1026.1999724383018, src:'/media/ports/coll_b_deco.png'},

      {id:10, n:'G_TRG', t:'s', s:1, v:true, x:1485.2203491693667, y:2577.607414515698, src:'/media/ports/coll_g_trg.png'},
      {id:9, n:'G_deco', t:'s', s:1, v:true, x:1606.0394333614822, y:2362.903372934741, src:'/media/ports/coll_g_deco.png'},

      {id:8, n:'SKY_0018.jpg', t:'s', s:2, v:true, x:3919.9999999999973, y:2046.6666666666647, src:'/media/ports/SKY_0018.jpg', mask: 7},
      {id:7, n:'PORT', t:'s', s:1, v:true, x:3965.087262131738, y:1747.1165002282185, src:'/media/ports/coll_port2.png'},
      {id:6, n:'bg', t:'s', s:1, src:'/media/ports/coll_bg.jpg', x:c_x, y:c_y, v:true},
      */

      // VNT
      {id:3, n:'port', t:'g', trg:[1,2]},
      {id:1, n:'TRG', t:'s', s:1, v:true, x:2655.0825627680783, y:1735.4905606646912, src:'/media/frame_trg.png'},
      {id:2, n:'frame', t:'s', s:1, v:true, x:c_x, y:c_y, src:'/media/frame.png'},
    ]



    // KEYS
    const Space = keyboard('Space')
    const Delete = keyboard('Delete')
    const ShiftLeft = keyboard('ShiftLeft')
    const ShiftRight = keyboard('ShiftRight')
    const KeyT = keyboard('KeyT')
    const keys = [Space, Delete, ShiftLeft, ShiftRight, KeyT]

    const toggleKB = value => {
      const method = ({false:'unsubscribe', true:'subscribe'})[value]
      for (let i of keys) {
        i[method]()
      }
    }


    const vueff = {}
    const selected = new Set()


    const canvas_div = document.querySelector('#canvas')
    const {Application, Container, Texture, Sprite, Graphics, Rectangle, Point, Text, TextStyle} = PIXI
    const loader = PIXI.Assets.loader
    const app = new Application({
      backgroundColor:0x999999,
      // width:init_width,
      // height:500,
      autoStart:false,
      antialias:false,
      resizeTo: canvas_div,
      hello: true,
    })
    canvas_div.appendChild(app.view)
    const stage = app.stage
    stage.name = 'stage'

    const origin = new Container()
    origin.setParent(stage)
    origin.name = 'origin'

    const scaled = new Container()
    scaled.setParent(origin)
    scaled.name = 'scaled'

    const page = new Container()
    page.setParent(scaled)
    page.name = 'page'
    scaled.scale.set(0.15)
    origin.position.set((app.screen.width-PAGE_W*0.15)/2, (app.screen.height-PAGE_H*0.15)/2)

    const page_mask = new Graphics()
    page_mask.setParent(page)
    page_mask.beginFill(0xff0000).drawRect(0,0,PAGE_W,PAGE_H).endFill()
    page.mask = page_mask

    const bg = new Graphics()
    bg.setParent(page)
    bg.beginFill(0xffffff).drawRect(-10,-10,PAGE_W+20,PAGE_H+20).endFill()


    const overlay = new Container()
    overlay.setParent(origin)
    overlay.name = 'overlay'

    const y_axis = new Graphics()
    y_axis.setParent(overlay)
    y_axis.lineStyle(2, 0x00ffff, .4).moveTo(0, -window.screen.height).lineTo(0, window.screen.height)
    const x_axis = new Graphics()
    x_axis.setParent(overlay)
    x_axis.lineStyle(2, 0x00ffff, .4).moveTo(-window.screen.width, 0).lineTo(window.screen.width, 0)


    const ctrl = new Container()
    ctrl.setParent(origin)
    ctrl.name = 'ctrl'
    const ctrl_pos = new Container()
    ctrl_pos.setParent(ctrl)
    //ctrl_pos.interactive = true
    ctrl_pos.visible = false
    const ctrls = {
      c: new Graphics(),
      l: new Graphics(),
      r: new Graphics(),
      t: new Graphics(),
      b: new Graphics(),
      tr: new Graphics(),
      br: new Graphics(),
    }
    ctrl_pos.addChild(ctrls.c, ctrls.l, ctrls.t, ctrls.r, ctrls.b, ctrls.tr, ctrls.br)
    ctrls.c.beginFill(0x0d6efd, 1).drawCircle(0,0,4).endFill()
    ctrls.l.lineStyle(2, 0x0d6efd, 1).moveTo(0,-0.5).lineTo(0,0.5)
    ctrls.t.lineStyle(2, 0x0d6efd, 1).moveTo(-0.5,0).lineTo(0.5,0)
    ctrls.r.lineStyle(2, 0x0d6efd, 1).moveTo(0,-0.5).lineTo(0,0.5)
    ctrls.b.lineStyle(2, 0x0d6efd, 1).moveTo(-0.5,0).lineTo(0.5,0)
    ctrls.tr.beginFill(0x0d6efd).drawCircle(0,0,6).endFill()
    ctrls.br.beginFill(0x0d6efd).drawRect(-5,-5,10,10).endFill()
    ctrls.r.interactive = ctrls.b.interactive = ctrls.tr.interactive = ctrls.c.interactive = ctrls.br.interactive = true
    ctrls.r.cursor = ctrls.b.cursor = ctrls.tr.cursor = ctrls.br.cursor = 'crosshair'
    ctrls.c.cursor = 'move'
    ctrls.r.hitArea = new Rectangle(-5, -0.5, 10, 1)
    ctrls.b.hitArea = new Rectangle(-0.5, -5, 1, 10)

    let active = null

    // drag move
    const ctrl_pos_on_mousedown_selected = e => {
      console.log('ctrl_pos_on_mousedown_selected')
      e.stopPropagation()
      const ll = {}
      for (let l of selected) {
        ll[l.id] = l.getGlobalPosition().subtract(e.global)
      }
      const p = ctrl_pos.getGlobalPosition().subtract(e.global)
      mmf = mm => {
        for (let l of selected) {
          let g = mm.global.add(ll[l.id])
          l.parent.toLocal(g, null, l.position)
        }
        ctrl_pos.parent.toLocal(mm.global.add(p), null, ctrl_pos.position)
      }
    }
    const ctrl_pos_on_mousedown_active = e => {
      console.log('ctrl_pos_on_mousedown_active')
      e.stopPropagation()
      const p = active.getGlobalPosition().subtract(e.global)

      mmf = mm => {
        const g = mm.global.add(p)
        active.parent.toLocal(g, null, active.position)
        ctrl_pos.parent.toLocal(g, null, ctrl_pos.position)
      }
    }
    const ctrl_pos_on_mousedown = e => {
      console.log('ctrl_pos_on_mousedown')
      if (Space.isDown) {
        console.log('Space.isDown')
        start_drag_page(e)
      } else if (selected.size > 1) {
        console.log('selected.size > 1')
        ctrl_pos_on_mousedown_selected(e)
      } else {
        console.log('else')
        ctrl_pos_on_mousedown_active(e)
      }
    }
    //ctrl_pos.on('mousedown', ctrl_pos_on_mousedown)
    ctrls.c.on('mousedown', ctrl_pos_on_mousedown)

    // scale right
    const on_scale_right2 = e => {
      e.stopPropagation()
      const m = e.global.clone()

      // norm vector along scale direction (in global space)
      const unit = new Point(Math.cos(active.rotation), Math.sin(active.rotation))

      const p = ctrl_pos.position.clone()
      const w = active.width

      const ctrl_t_w = ctrls.t.width
      const ctrl_l_x = ctrls.l.x

      mmf = mm => {
        // mouse move delta along scale norm vector
        // mouse move vector projection to scale norm vector
        // (in global space)
        const mm_proj = proj(mm.global.subtract(m), unit)

        //console.log('x', mm_proj.x, 'y', mm_proj.y)

        // new ctrl position, old position + half delta of mouse move projection to
        // norm vector (ctrl position exists in global space)
        ctrl_pos.position.set(p.x + mm_proj.x/2, p.y + mm_proj.y/2)

        // update ctrl graphics
        ctrls.t.width = ctrls.b.width = ctrl_t_w + mm_proj.length
        const v = ctrl_l_x - mm_proj.length/2
        ctrls.l.x = v
        ctrls.r.x = ctrls.tr.x = ctrls.br.x = -v

        // ctrl position in ctrl overlay + global origin position =>
        // ctrl global position
        // new active layer position - is ctrl new global position translated to
        // active layer local space
        active.parent.toLocal(ctrl_pos.position.add(origin.position), null, active.position)

        // new active layer width - is old width + mouse move projection to scale
        // vector corrected by scale (translated to local space)
        // TODO: take into account if active layer is inside another scaled container
        active.width = w + mm_proj.length/scaled.scale.x

        app.render()
      }

      mmef = () => {
        ctrls.c.hitArea = new Rectangle(ctrls.l.x, ctrls.t.y, ctrls.t.width, ctrls.l.height)
      }
    }
    ctrls.r.on('mousedown', on_scale_right2)

    // scale bottom
    const on_scale_bottom2 = e => {
      e.stopPropagation()
      const m = e.global.clone()
      const unit = new Point(Math.cos(active.rotation+Math.PI/2), Math.sin(active.rotation+Math.PI/2))
      const p = ctrl_pos.position.clone()
      const h = active.height

      const ctrl_h = ctrls.l.height
      const ctrl_t_y = ctrls.t.y

      mmf = mm => {
        const mm_proj = proj(mm.global.subtract(m), unit)
        ctrl_pos.position.set(p.x + mm_proj.x/2, p.y + mm_proj.y/2)
        ctrls.l.height = ctrls.r.height = ctrl_h + mm_proj.length
        ctrls.t.y = ctrls.tr.y = ctrl_t_y - mm_proj.length/2
        ctrls.b.y = ctrls.br.y = -ctrl_t_y + mm_proj.length/2
        active.parent.toLocal(ctrl_pos.position.add(origin.position), null, active.position)
        active.height = h + mm_proj.length/scaled.scale.x
        app.render()
      }

      mmef = () => {
        ctrls.c.hitArea = new Rectangle(ctrls.l.x, ctrls.t.y, ctrls.t.width, ctrls.l.height)
      }
    }
    ctrls.b.on('mousedown', on_scale_bottom2)

    // scale bottom right
    const on_scale_br2 = e => {
      e.stopPropagation()
      const m = e.global.clone()
      const diag_rad = Math.acos(ctrls.t.width / Math.hypot(ctrls.t.width, ctrls.l.height)) + active.rotation
      const unit = new Point(Math.cos(diag_rad), Math.sin(diag_rad))
      const p = ctrl_pos.position.clone()
      const w = active.width
      const h = active.height
      const ctrl_t_w = ctrls.t.width-4
      const ctrl_l_h = ctrls.l.height-4
      const ctrl_t_y = ctrls.t.y+1
      const ctrl_l_x = ctrls.l.x+1
      const d = Math.hypot(ctrl_t_w, ctrl_l_h)
      const scale = active.scale.clone()
      mmf = mm => {
        const mm_proj = proj(mm.global.subtract(m), unit)
        ctrl_pos.position.set(p.x + mm_proj.x/2, p.y + mm_proj.y/2)
        //ctrls.t.width = ctrls.b.width = ctrl_t_w + mm_proj.x
        //ctrls.l.height = ctrls.r.height = ctrl_l_h + mm_proj.y
        //ctrls.t.width = ctrls.b.width = ctrl_t_w * mm_proj.length
        //ctrls.l.height = ctrls.r.height = ctrl_l_h * mm_proj.length
        const s = (d + mm_proj.length)/d
        ctrls.t.width = ctrls.b.width = ctrl_t_w * s+4
        ctrls.l.height = ctrls.r.height = ctrl_l_h * s+4
        //const v = ctrl_l_x - mm_proj.x/2
        //const u = ctrl_t_y - mm_proj.y/2
        //ctrls.l.x = ctrl_l_x * mm_proj.length/2
        ctrls.l.x = ctrl_l_x * s -1
        ctrls.r.x = ctrls.tr.x = ctrls.br.x = -ctrl_l_x * s +1
        ctrls.t.y = ctrls.tr.y = ctrl_t_y * s -1
        ctrls.b.y = ctrls.br.y = -ctrl_t_y * s +1
        active.parent.toLocal(ctrl_pos.position.add(origin.position), null, active.position)
        scale.multiplyScalar(s, active.scale)
        app.render()
      }
      mmef = () => {
        ctrls.c.hitArea = new Rectangle(ctrls.l.x, ctrls.t.y, ctrls.t.width, ctrls.l.height)
      }
    }
    ctrls.br.on('mousedown', on_scale_br2)

    const on_rotate_selected = e => {
      e.stopPropagation()
      const c = ctrl_pos.getGlobalPosition()
      const ctrl_p = page.toLocal(c, null)
      const m_c = e.global.subtract(c)
      const rot = Math.atan2(m_c.y, m_c.x)
      const ctrl_rot = ctrl_pos.rotation
      const rotation = {}
      const position = {}
      for (let l of selected) {
        rotation[l.id] = l.rotation
        position[l.id] = l.position.subtract(ctrl_p)
      }
      mmf = mm => {
        const m_c1 = mm.global.subtract(c)
        const delta_rot = Math.atan2(m_c1.y, m_c1.x) - rot
        ctrl_pos.rotation = ctrl_rot + delta_rot

        const cos = Math.cos(delta_rot)
        const sin = Math.sin(delta_rot)
        for (let l of selected) {
          l.rotation = rotation[l.id] + delta_rot
          l.x = position[l.id].x * cos - position[l.id].y * sin + ctrl_p.x
          l.y = position[l.id].y * cos + position[l.id].x * sin + ctrl_p.y
        }

        app.render()
      }
    }

    const on_rotate = e => {

      if (selected.size > 1) {
        on_rotate_selected(e)
        return
      }

      e.stopPropagation()
      const c = ctrl_pos.getGlobalPosition()
      const v = e.global.subtract(c)
      const r = active.rotation - Math.atan2(v.y, v.x)
      mmf = mm => {
        const v1 = mm.global.subtract(c)
        ctrl_pos.rotation = active.rotation = r + Math.atan2(v1.y, v1.x)
        app.render()
      }
    }
    ctrls.tr.on('mousedown', on_rotate)

    const destroyCtrl = () => {
      if (!ctrl_pos.visible) {return}
      /*
      for (let i = ctrl_pos.children.length-1;i>=0;i--) {
        ctrl_pos.children[i].destroy({children:true})
      }
      ctrl_pos.destroy({children:true})
      ctrl_pos = null
      */
      ctrl_pos.visible = false
      active = null

      selected.clear()

      vueff.selectLayerId()
      app.render()
    }

    const calcScale = active => {
      let parent = active.parent
      let sx = parent.scale.x
      let sy = parent.scale.y
      while (parent.name !== 'origin') {
        sx *= parent.scale.x
        sy *= parent.scale.y
        parent = parent.parent
      }
      return [sx, sy]
    }

    const drawSelectedCtrl = () => {
      let ll = Infinity
      let rr = -Infinity
      let tt = Infinity
      let bb = -Infinity

      for (let i of selected) {
        let bounds = i.getBounds()
        ll = Math.min(ll, bounds.x)
        rr = Math.max(rr, bounds.x + bounds.width)
        tt = Math.min(tt, bounds.y)
        bb = Math.max(bb, bounds.y + bounds.height)
      }

      const ww = rr - ll
      const hh = bb - tt
      const w2 = ww/2
      const h2 = hh/2

      ctrl_pos.position.set((ll+rr)/2-origin.x, (tt+bb)/2-origin.y)
      ctrl_pos.angle = 0
      ctrls.r.x = ctrls.tr.x = ctrls.br.x = w2+1
      ctrls.l.x = -ctrls.r.x
      ctrls.b.y = ctrls.br.y = h2+1
      ctrls.t.y = ctrls.tr.y = -ctrls.b.y
      ctrls.t.width = ctrls.b.width = ww+4
      ctrls.l.height = ctrls.r.height = hh+4
      ctrls.c.hitArea = new Rectangle(-w2, -h2, ww, hh)
      ctrl_pos.visible = true
      app.render()
    }

    const drawActiveCtrl = () => {
      const bounds = active.getLocalBounds()

      const [sx, sy] = calcScale(active)
      const ww = bounds.width * sx * active.scale.x
      const hh = bounds.height * sy * active.scale.y
      const w2 = ww/2
      const h2 = hh/2

      ctrl_pos.parent.toLocal(active.getGlobalPosition(), null, ctrl_pos.position)
      ctrl_pos.angle = active.angle
      ctrls.l.height = ctrls.r.height = hh+4
      ctrls.t.width = ctrls.b.width = ww+4
      ctrls.r.x = ctrls.tr.x = ctrls.br.x = w2+1
      ctrls.b.y = ctrls.br.y = h2+1
      ctrls.t.y = ctrls.tr.y = -ctrls.b.y
      ctrls.l.x = -ctrls.r.x
      ctrls.c.hitArea = new Rectangle(-w2, -h2, ww, hh)
      ctrl_pos.visible = true
      app.render()
    }

    const layer_click = e => {
      if (Space.isDown) {
        start_drag_page(e)
        return
      }

      const shift = ShiftLeft.isDown || ShiftRight.isDown

      if (!shift) {selected.clear()}

      active = e.target
      selected.add(active)
      vueff.selectLayerId(active.id)

      if (selected.size > 1) {
        drawSelectedCtrl()
      } else {
        drawActiveCtrl()
      }

      ctrl_pos_on_mousedown(e)
    }

    const select_layers = (...layIds) => {
      const shift = ShiftLeft.isDown || ShiftRight.isDown
      if (!shift) {selected.clear()}
      for (let layId of layIds) {
        let lay = lays[layId]
        if (!lay) {continue}
        selected.add(lay)
        active = lay
      }
      if (selected.size > 1) {
        drawSelectedCtrl()
      } else {
        drawActiveCtrl()
      }
    }

    const stage_click = e => {
      if (Space.isDown) {
        start_drag_page(e)
      } else (
        destroyCtrl(e)
      )
    }

    const update_axis = () => {
      x_axis.x = app.screen.width/2-origin.x
      y_axis.y = app.screen.height/2-origin.y
    }

    const start_drag_page = e => {
      const p = origin.position.subtract(e.global)
      mmf = mm => {
        mm.global.add(p, origin.position)
        update_axis()
      }
    }

    const on_zoom = e => {
      e.stopPropagation()
      const c = new Point(app.screen.width/2, app.screen.height/2)
      const x = e.global.x
      const s = scaled.scale.x
      const p = origin.position.clone()
      mmf = mm => {
        const k = 1 + (mm.global.x - x) / app.screen.width
        scaled.scale.set(s * k)

        p.subtract(c).multiplyScalar(k).add(c, origin.position)

        update_axis()

        //if (active) {drawCtrl(active, true)}
        if (selected.size > 1) {drawSelectedCtrl()}
        else if (selected.size === 1) {drawActiveCtrl()}
        else {app.render()}
      }
    }

    const stage_zoom_ctrl = new Graphics()
    stage_zoom_ctrl.setParent(stage)
    stage_zoom_ctrl.beginFill(0x00ffff, .4).drawRect(-10, -10, 20, 20).endFill()
    stage_zoom_ctrl.position.set(app.screen.width/2+11, app.screen.height - 15)
    stage_zoom_ctrl.interactive = true
    stage_zoom_ctrl.cursor = 'zoom-in'
    stage_zoom_ctrl.on('mousedown', on_zoom)

    const stage_move_ctrl = new Graphics()
    stage_move_ctrl.setParent(stage)
    stage_move_ctrl.beginFill(0x00ffff, .4).drawRect(-15, -15, 30, 30).endFill()
    stage_move_ctrl.position.set(app.screen.width/2-16, app.screen.height - 20)
    stage_move_ctrl.interactive = true
    stage_move_ctrl.cursor = 'move'
    stage_move_ctrl.on('mousedown', e => {
      e.stopPropagation()
      start_drag_page(e)
    })

    let mmf = null
    let mmef= null

    stage.interactive = true
    stage.hitArea = new Rectangle(
      -window.screen.width, -window.screen.height,
      2*window.screen.width, 2*window.screen.height
    )
    stage.on('mouseup', e => {
      mmf = null
      if (mmef) {
        mmef(e)
        mmef = null
      }
    })
    stage.on('mouseupoutside', e => {
      mmf = null
      if (mmef) {
        mmef(e)
        mmef = null
      }
    })
    stage.on('mousemove', e => {
      if (mmf) {
        mmf(e)
        app.render()
      }
    })
    stage.on('mousedown', stage_click)
    stage.on('wheel', e => {
      const k = e.deltaY < 0 ? 1.1 : 0.9090909090909091

      // (origin - e.global) * s + e.global
      origin.position.subtract(e.global).multiplyScalar(k).add(e.global, origin.position)
      scaled.scale.set(scaled.scale.x * k)
      update_axis()

      //if (active) {drawCtrl(active, true)}
      //if (active) {drawActiveCtrl()}
      if (selected.size > 1) {drawSelectedCtrl()}
      else if (selected.size === 1) {drawActiveCtrl()}
      else {app.render()}
    })

    const lays = {}

    // DRAW LAYERS
    const drawRectLay = lay => {
      const obj = new Graphics()
      obj.setParent(page)
      obj.beginFill(lay.col).drawRect(-0.5*lay.w, -0.5*lay.h, lay.w, lay.h).endFill()
      obj.position.set(lay.x||0, lay.y||0)
      obj.interactive = true
      obj.on('mousedown', layer_click)
      obj.name = lay.n
      obj.id = lay.id
      lays[lay.id] = obj
      lay.obj = obj
    }

    const drawSpriteLay = lay => {
      const tmp = new Container()
      tmp.setParent(page)
      tmp.name = lay.n
      tmp.id = lay.id
      loader.load(lay.src).then(tex=>{
        const obj = new Sprite(tex)
        page.addChildAt(obj, page.getChildIndex(tmp))
        tmp.removeFromParent()
        obj.anchor.set(.5)
        obj.scale.set(lay.sx||lay.s||1, lay.sy||lay.s||1)
        obj.position.set(lay.x||0, lay.y||0)
        obj.interactive = true
        obj.on('mousedown', layer_click)
        obj.name = lay.n
        obj.id = lay.id
        lays[lay.id] = obj
        lay.obj = obj
        app.render()
      })
    }

    const drawTextLay = lay => {
      const obj = new Text(lay.text, new TextStyle(lay.textStyle))
      obj.setParent(page)
      obj.anchor.set(.5)
      obj.position.set(lay.x||0, lay.y||0)
      obj.interactive = true
      obj.on('mousedown', layer_click)
      obj.name = lay.n
      obj.id = lay.id
      lays[lay.id] = obj
      lay.obj = obj
    }

    const drawLay = lay => {
      if (lay.t in drawLay.map) {
        drawLay.map[lay.t](lay)
      }
    }
    drawLay.map = {
      r: drawRectLay,
      s: drawSpriteLay,
      t: drawTextLay,
    }

    for (let i = doc_lays.length-1;i>=0;i--) {drawLay(doc_lays[i])}
    for (let lay of doc_lays) {
      if (lay.mask) {
        let mask_lay = doc_lays.find(l => l.id === lay.mask)
        if (mask_lay && (lay.src || mask_lay.src)) {
          PIXI.Assets.load([lay, mask_lay].filter(l=>l.src).map(l=>l.src)).then(() => {
            lays[lay.id].mask = lays[mask_lay.id]
            app.render()
          })
        }
      }
    }

    Delete.press = () => {
      if (active) {
        vueff.deleteLayerId(active.id)
        active.destroy({children:true})
        destroyCtrl()
      }
    }



    app.render()
  </script>

  <!-- TEMPLATES -->
  <template id='laycard-template'>
    <div
      @click='selectLayer(lay, $event)'
      :class='is_selected?"border-primary":""'
      class="border border-2 user-select-none d-flex align-items-center"
      style="height:33.3333%;width:150px;"
    >

      <button @click.stop='toggleVisible()' class="btn btn-sm p-0">
        <i class="bi bi-eye-fill" :class="{[`bi-eye-${lay.v?'fill':'slash'}`]:true}"></i>
      </button>

      {% comment %} <span class="dropup dropup-center d-inline-block">

        <button class="btn p-0" data-bs-toggle="dropdown" data-bs-auto-close="outside">
          <i class="bi bi-three-dots"></i>
        </button>

        <div class="dropdown-menu p-2 shadow border-1">

          <template v-if="lay.t === 't'">
            <textarea v-fullkeyboard cols="30" rows="2" v-model='lay.text' class=""></textarea>

            <label>
              <input v-fullkeyboard type="checkbox" v-model='lay.textStyle.trim'>
              Trim
            </label>
          </template>

          <label>
            <input type="number" v-model='lay.angle'>
            Angle
          </label>

          <div class="accordion">

            <template v-if="lay.t === 't'">

            <div class="accordion-item">
              <h4 class="accordion-header">
                <button class="accordion-button p-1 px-2" data-bs-toggle="collapse" data-bs-target="#font-collapse">Шрифт</button>
              </h4>

              <div id="font-collapse" class="accordion-collapse collapse show">
                <div class="accordion-body p-1">
                  <label class="d-block">
                    <input v-fullkeyboard style="width:4em;" type="number" v-model='lay.textStyle.fontSize'>
                    Размер
                  </label>

                  <label class="d-block">
                    <input v-fullkeyboard type="color" v-model='lay.textStyle.fill'>
                    Цвет
                  </label>

                  <div>
                    <input id="align-left" type="radio" class="btn-check" name="align" value="left" v-model='lay.textStyle.align' autocomplete="off">
                    <input id="align-center" type="radio" class="btn-check" name="align" value="center" v-model='lay.textStyle.align' autocomplete="off">
                    <input id="align-right" type="radio" class="btn-check" name="align" value="right" v-model='lay.textStyle.align' autocomplete="off">
                    <div class="btn-group btn-group-sm">
                      <button
                        class="btn p-0"
                        :class="{[`btn${lay.textStyle.align==='left'?'':'-outline'}-secondary`]:true}"
                      ><label class="p-1 px-2" for='align-left'><i class="bi bi-text-left"></i></label></button>

                      <button
                        class="btn p-0"
                        :class="{[`btn${lay.textStyle.align==='center'?'':'-outline'}-secondary`]:true}"
                      ><label class="p-1 px-2" for="align-center"><i class="bi bi-text-center"></i></label></button>

                      <button
                        class="btn p-0"
                        :class="{[`btn${lay.textStyle.align==='right'?'':'-outline'}-secondary`]:true}"
                      ><label class="p-1 px-2" for="align-right"><i class="bi bi-text-right"></i></label></button>
                    </div>
                  </div>

                  <div>
                    <input type="checkbox" id="weight-bold" class="btn-check" autocomplete="off" v-model='lay.textStyle.fontWeight' value="bold">
                    <input type="checkbox" id="style-italic" class="btn-check" autocomplete="off" v-model='lay.textStyle.fontStyle' value="italic">
                    <div class="btn-group btn-group-sm">
                      <button
                        class="btn p-0"
                        :class="{[`btn${lay.textStyle.fontWeight==='bold'?'':'-outline'}-secondary`]:true}"
                      ><label for="weight-bold" class="p-1 px-2"><i class="bi bi-type-bold"></i></label></button>

                      <button
                        class="btn p-0"
                        :class="{[`btn${lay.textStyle.fontStyle==='italic'?'':'-outline'}-secondary`]:true}"
                      ><label for="style-italic" class="p-1 px-2"><i class="bi bi-type-italic"></i></label></button>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div class="accordion-item">
              <h4 class="accordion-header">
                <button class="accordion-button p-1 px-2 collapsed" data-bs-toggle="collapse" data-bs-target="#font-outline">Обводка</button>
              </h4>

              <div id="font-outline" class="accordion-collapse collapse">
                <div class="accordion-body p-1">
                  <label class="d-block">
                    <input v-fullkeyboard type="number" style="width:4em;" v-model='lay.textStyle.strokeThickness'>
                    Толщина
                  </label>

                   <label class="d-block">
                     <input v-fullkeyboard type="color" v-model='lay.textStyle.stroke'>
                     Цвет
                   </label>
                </div>
              </div>
            </div>

            </template>

          </div>

        </div>

      </span> {% endcomment %}

      <button v-if='lay.mask' class="btn btn-sm p-0"><i class="bi bi-transparency"></i></button>

      <button v-if="lay.mask" class="btn btn-sm p-0"><i class="bi bi-arrow-90deg-down"></i></button>

      <span class="overflow-hidden">[[ lay.n ]]</span>

    </div>
  </template>

  <template id='vueapp-template'>
    <div class='d-flex flex-column flex-wrap align-content-start bg-white shadow-lg w-100' style="height:100px;">
      <lay-card v-for='lay in layers' :lay='lay'></lay-card>
    </div>

    {% comment %} <Teleport to="#canvas">
      <div v-if="active" class="position-absolute shadow" style="top:20px;left:20px;">
        <input v-fullkeyboard type="number" class="form-control" :value='active.value.obj.x' @input='on_input'>
      </div>
    </Teleport> {% endcomment %}
  </template>

  <!-- VUE -->
  <script>
    const eq = (field, value) => (item) => item[field] === value
    const id = value => eq('id', value)

    const updateTextLayer = (layer, newValue, old) => {
      const obj = lays[layer.id]
      obj.text = newValue.text
      for (let k in newValue.textStyle) {
        obj.style[k] = newValue.textStyle[k]
      }
      if (obj === active) {
        //drawCtrl(obj, true)
      }
      app.render()
    }

    onLoad(() => {
      const {ref, reactive, computed, watch} = Vue


      const layers = vueff.layers = reactive(doc_lays)
      const selected2 = vueff.selected2 = reactive(new Set())
      const selectLayer = (lay, event) => {
        if (!event.shiftKey) {selected2.clear()}
        selected2.add(lay)
        //console.log('lay', lay)
        if (lay.t === 'g') {
          select_layers(...lay.trg)
          for (let layId of lay.trg) {
            let lay2 = layers.find(id(layId))
            if (!lay2) {continue}
            selected2.add(lay2)
          }
        } else {
          select_layers(lay.id)
        }
      }
      vueff.selectLayerId = (layId) => {
        const shift = ShiftLeft.isDown || ShiftRight.isDown

        if (!shift) {selected2.clear()}

        if (!layId) {return}
        const lay = layers.find(id(layId))
        if (!lay) {return}

        selected2.add(lay)
      }
      vueff.deleteLayerId = (layId) => {
        layers.splice(layers.findIndex(l=>l.id===layId), 1)
      }
      layers.forEach(layer => {
        if (layer.t === 't' && layer.id in lays) {
          watch(layer, (val, old) => {
            updateTextLayer(layer, val, old)
          })
        }
      })

      /*
      const active = computed(() => {
        if (!selected2.size) {return}
        const tmp = selected2.values().next()
        if (tmp.t === 'g') {return}
        return tmp
      })
      const on_input = (event) => {
        console.log('active', active)
        const value = parseFloat(event.target.value)
        active.value.value.obj.x = value
        app.render()
      }
      */


      const LayCard = {
        template: '#laycard-template',
        props: ['lay'],
        setup(props) {
          const is_selected = computed(() => {
            return selected2.has(props.lay)
          })

          const toggleVisible = (value) => {
            const obj = lays[props.lay.id]
            props.lay.v = value == undefined ? !props.lay.v : value
            obj.visible = props.lay.v
            app.render()
          }

          return {selectLayer, is_selected, toggleVisible}
        },
      }


      const vueapp = window.vueapp = Vue.createApp({
        template: '#vueapp-template',
        components: {LayCard},
        setup() {
          //return {layers, selected2, active, on_input}
          return {layers, selected2}
        },
      })
      vueapp.config.compilerOptions.delimiters = ['[[', ']]']
      const onInputFocus = () => {toggleKB(false)}
      const onInputBlur = () => {toggleKB(true)}
      vueapp.directive('fullkeyboard', {
        mounted(el) {
          el.addEventListener('focus', onInputFocus)
          el.addEventListener('blur', onInputBlur)
        },
        beforeUnmount(el) {
          el.removeEventListener('focus', onInputFocus)
          el.removeEventListener('blur', onInputBlur)
        },
      })
      vueapp.mount('#vue-app')
    })
  </script>

  <!-- DROP -->
  <script>
    onLoad(() => {
      const dropArea = document.querySelector('#canvas')

      const preventAndStop = e => {
        e.preventDefault()
        e.stopPropagation()
      }

      const highlightDropArea = event => {
        if (['dragleave', 'drop'].includes(event)) {
          dropArea.style.opacity=1
        } else if (['dragenter', 'dragover'].includes(event)) {
          dropArea.style.opacity=.5
        }
      }

      const handleDrop = (event, e) => {
        if (event === 'drop') {
          const files = e.dataTransfer.files
          ;[...files].forEach(file => {
            const formData = new FormData()
            formData.set('file', file)
            fetch('{{ request.path }}', {
              method: 'POST',
              body: formData,
              headers: {'X-CSRFToken': '{{ csrf_token }}'},
            }).then(res=>res.json()).then(data=>{
              if (data.status === 'OK' && data.src) {
                PIXI.Assets.load([data.src]).then(() => {
                  const max_id = doc_lays.reduce((m,i) => i.id>m?i.id:m, 1)
                  const new_lay = {
                    id:max_id+1,
                    t:'s',
                    s:1,
                    x:c_x,
                    y:c_y,
                    v:true,
                    n:data.src.split('/').slice(-1)[0],
                    src:data.src,
                  }
                  //doc_lays.unshift(new_lay)
                  drawLay(new_lay)
                  app.render()
                  vueff.layers.unshift(new_lay)
                })
              }
            })
          })
        }
      }

      ;['dragenter', 'dragleave', 'dragover', 'drop'].forEach(event => {
        dropArea.addEventListener(event, (e) => {
          preventAndStop(e)
          highlightDropArea(event)
          handleDrop(event, e)
        }, false)
      })
    })
  </script>

{% endblock js %}
