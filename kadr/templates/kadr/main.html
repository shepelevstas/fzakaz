{% extends 'kadr/base.html' %}

{% load static %}

{% block content %}
  <div class="container">
    <h4>Кадрирование</h4>
  </div>

  <div class="roster">
    {% for port in ports %}
      <div class="port d-inline-block position-relative border overflow-hidden" style="aspect-ratio:102/152;width:100px;">
        <img src="{{ port.mini }}" data-src="{{ port.src }}" class="position-absolute" style="width:147%;left:8.3%;top:5.57%;">
      </div>
    {% endfor %}
  </div>
{% endblock content %}

{% block js %}
  <script>
    const lim = (a,b,x) => Math.min(Math.max(a,x),b)
    // point multiplication/scaling
    // pmul(2, {x:2, y:3}) == {x:4, y:6}
    // (Float, Point) -> Point
    const pmul = (m, p) => ({x:p.x * m, y:p.y * m})
    const pdiv = (p, d) => ({x:p.x / d, y:p.y / d})

    // (Point, Point) -> Point
    const padd = (a, b) => ({x:a.x + b.x, y:a.y + b.y})

    // (Point, Point) -> Point
    const pdif = (a, b) => ({x:a.x - b.x, y:a.y - b.y})

    // (Point, Point) -> Number
    const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y)
  </script>

  <script>
    function keyboard(value) {
      const key = {};
      key.value = value;
      key.isDown = false;
      key.isUp = true;
      key.press = undefined;
      key.release = undefined;
      //The `downHandler`
      key.downHandler = (event) => {
        if (event.code === key.value) {
          if (key.isUp && key.press) {
            key.press();
          }
          key.isDown = true;
          key.isUp = false;
          event.preventDefault();
        }
      };

      //The `upHandler`
      key.upHandler = (event) => {
        if (event.code === key.value) {
          if (key.isDown && key.release) {
            key.release();
          }
          key.isDown = false;
          key.isUp = true;
          event.preventDefault();
        }
      };

      //Attach event listeners
      const downListener = key.downHandler.bind(key);
      const upListener = key.upHandler.bind(key);

      window.addEventListener("keydown", downListener, false);
      window.addEventListener("keyup", upListener, false);

      // Detach event listeners
      key.unsubscribe = () => {
        window.removeEventListener("keydown", downListener);
        window.removeEventListener("keyup", upListener);
      };

      return key;
    }
  </script>

  <script>
    const {Application, Container, Texture, Sprite, Graphics, Rectangle, Point} = PIXI
    const loader = PIXI.Assets.loader
    const app = new Application({
      backgroundColor:0x999999,
      width:500,
      height:500,
      autoStart:true,
      antialias:false,
    })
    document.body.appendChild(app.view)
    const stage = app.stage

    const vars = {px_in_mm: 300 / 25.4}

    const imgs = (function(){
      const imgs = function(list) {
        imgs._list = list
        imgs._cur = null
        imgs._index = -1
        imgs._imgs = {}
        imgs._tex = {}
        imgs._spr = {}
      }
      imgs._get_tex = function(src) {
        if (src in this._tex) {
          return Promise.resolve(this._tex[src])
        }
        return loader.load(src).then(tex=>{
          this._tex[src] = tex
          return tex
        })
      }
      imgs._get_spr = function(src, inst=1) {
        const sprites_key = src + inst
        if (sprites_key in this._spr) {
          return Promise.resolve(this._spr[sprites_key])
        }
        return this._get_tex(src).then(tex => {
          const spr = new Sprite(tex)
          this._spr[sprites_key] = spr
          spr.anchor.set(0.5)
          return spr
        })
      }
      imgs._get_img = function(src) {
        if (src in this._imgs) {
          return this._imgs[src]
        }
        const img = {}
        this._imgs[src] = img
        img._this = this
        img._src = src

        img.save = function(what){

        }

        img.spr = this._get_spr(src)
        img.ghost = this._get_spr(src, 2)

        return img
      }
      imgs.cur = function() {
        if (this._index > -1) {
          return this._get_img(this._list[this._index])
        }
        return this.first()
      }
      imgs.last = function() {
        this._index = this._list.length - 1
        return this._get_img(this._list[this._index])
      }
      imgs.first = function() {
        this._index = 0
        return this._get_img(this._list[this._index])
      }
      imgs.next = function() {
        if (this._index >= this._list.length) {
          return this.last()
        }
        this._index++
        return this._get_img(this._list[this._index])
      }
      imgs.prev = function() {
        if (this._index <= 0) {
          return this.first()
        }
        this._index--
        return this._get_img(this._list[this._index])
      }

      return imgs
    })()

    const layer = (function(){
      const layer = function(name_or_img, img) {
        let name = null

        if (typeof(name_or_img)==='string') {
          name = name_or_img
        } else if (typeof(name_or_img)==='object') {
          img = name_or_img
        }

        if (name && img) {
          if (name in layer._by_name && img === layer._get_by_name(name)) {
            return layer._get_by_name(name)
          }
          if (img._src in layer._by_img) {
            layer._by_name[name] = layer._get_by_img(img)
            return layer._get_by_name(name)
          }
          return layer._set(name, img)
        }

        if (name===null && img) {
          if (!(img._src in layer._by_img)) {
            return layer._set('default', img)
          }
          return layer._get_by_img(img)
        }

        if (name && img===undefined) {
          if (name in layer._by_name) {
            return layer._get_by_name(name)
          }
        }

        if (name===null && img===undefined) {
          return layer._get_by_name('default')
        }

        return
      }
      layer._by_name = {}
      layer._by_img = {}
      layer._set = function(name, img) {
        const lay = {}
        lay._this = this
        lay._img = img

        this._by_name[name] = lay
        this._by_img[img._src] = lay

        lay._img_ready = function(k,f) {
          if (img[k] instanceof Promise) {
            img[k].then(res => {
              img[k] = res
              f(res)
              return res
            })
          } else {
            f(img[k])
          }
        }

        lay._ready = function(spr_f, ghost_f) {
          lay._img_ready('spr', spr_f)
          lay._img_ready('ghost', ghost_f || spr_f)
          return lay
        }

        lay.pos = function(point) {
          if (img.spr instanceof Promise) {return}

          if (point === undefined) {
            return img.spr.position
          }

          if (typeof(point)==='function') {
            vars.mmf = mm => {
              img.spr.position.copyFrom(point(mm))
              img.ghost.position.copyFrom(img.spr.position)
            }
            return lay
          }

          img.spr.position.copyFrom(point)
          img.ghost.position.copyFrom(point)

          return lay
        }

        lay.show = function() {
          return lay._ready(spr => {
            spr.setParent(page.page)
          }, ghost => {
            ghost.setParent(page.ghost)
          })
        }

        lay.hide = function() {
          return lay._ready(spr => {
            spr.removeFromParent()
          })
        }

        lay.move = function(x,y) {
          return lay._ready(spr => {
            spr.x = x
            spr.y = y
          })
        }

        lay.scale = function(value) {
          return lay._ready(spr => {
            spr.scale.set(value)
          })
        }

        return lay
      }
      layer._get_by_name = function(name) {
        return this._by_name[name]
      }
      layer._get_by_img = function(img) {
        return this._by_img[img._src]
      }

      return layer
    })()

    const page = (function(){
      const page = function(w,h){
        /*  - stage
              - pos (page and complementary items position)
                - scaled (all staff that should be scaled together)
                  - ghost
                    + (ghost layers)
                  - page
                    - mask
                    - white
                    + (layers)
                - guides
                  + (guides)
                - page_ctrl
              - stage_ctrl
        */
        if (page.pos) {return page}

        if (typeof(w)==='string') {
          if (w.slice(-2)==='mm') {
            w = parseFloat(w) * vars.px_in_mm
          }
        }
        if (typeof(h)==='string') {
          if (h.slice(-2)==='mm') {
            h = parseFloat(h) * vars.px_in_mm
          }
        }

        const pos = new Container()
        page.pos = pos
        pos.setParent(stage)

        const scaled = new Container()
        page.scaled = scaled
        scaled.setParent(pos)

        const ghost = new Container()
        page.ghost = ghost
        ghost.setParent(scaled)
        ghost.alpha = 0.1

        const _page = new Container()
        page.page = _page
        _page.setParent(scaled)

        const mask = new Graphics()
        page.mask = mask
        mask.setParent(_page)
        mask.beginFill(0xff0000).drawRect(-w/2,-h/2,w,h).endFill()
        _page.mask = mask

        const white = new Graphics()
        page.white = white
        white.setParent(_page)
        white.beginFill(0xffffff).drawRect(-w/2-10,-h/2-10,w+20,h+20).endFill()

        const guides = new Container()
        page.guides = guides
        guides.setParent(pos)

        const page_ctrl = new Container()
        page.page_ctrl = page_ctrl
        page_ctrl.setParent(pos)

        const stage_ctrl = new Container()
        page.stage_ctrl = stage_ctrl
        stage_ctrl.setParent(stage)

        const page_ratio = w / h
        const app_ratio = app.view.width / app.view.height
        const init_zoom = app_ratio > page_ratio
          ? (app.view.height - 100) / h
          : (app.view.width - 100) / w

        return page.zoom(init_zoom).center()
      }
      page.height = function() {
        return this.mask.height * this.zoom()
      }
      page.width = function() {
        return this.mask.width * this.zoom()
      }
      page.zoom = function(value) {
        if (value === undefined) {
          return this.scaled.scale.x
        }
        this.scaled.scale.set(value)
        guide.update()
        ctrl.update()
        return this
      }
      page.center = function() {
        this.move(app.screen.width/2, app.screen.height/2)
        return this
      }
      page.move = function(x=0,y=x) {
        this.pos.position.set(x,y)
        ctrl.update()
        return this
      }

      return page
    })()

    const guide = (function(){
      const guide = function(value) {
        let g = guide._guides.find(i => i.value === value)
        if (g===undefined) {
          const gr = new Graphics()
          gr.setParent(page.guides)

          gr.lineStyle(1, 0x00ffff, .4).lineTo(window.screen.width*2, 0)
          gr.x = -window.screen.width
          // gr.y = page.height() * (value - 0.5)

          g = {value, gr}
          g.set = function(value) {
            this.value = value
            guide.update()
          }
          guide._guides.push(g)
          guide._guides.sort((a,b) => a.value - b.value)
          guide.update()
        }
        return g
      }
      guide._guides = []
      guide.len = function() {
        return this._guides.length
      }
      guide.update = function() {
        const page_height = page.height()
        this._guides.forEach(g => {
          g.gr.y = page_height * (g.value - 0.5)
        })
        ctrl.update()
        return this
      }
      guide.item = function(index=0) {
        return this._guides[index]
      }
      guide.min = function(index=0) {
        // this._guides.sort((a,b) => a.value-b.value)
        return this._guides[index]
      }

      return guide
    })()

    const ctrl = (function(){
      const ctrl = function(layer) {
        stage.interactive = true

        stage.hitArea = new Rectangle(
          -window.screen.width,
          -window.screen.height,
          2*window.screen.width,
          2*window.screen.height,
        )

        stage.on('pointermove', mm => {
          vars.mm = mm
          if (vars.mmf) {
            vars.mmf(mm)
          }
        })

        stage.on('pointerup', mm => {
          console.log('up')
          vars.mmf = null
          if (vars.mmef) {
            vars.mmef(mm)
            vars.mmef = null
          }
        })

        stage.on('pointerupoutside', mm => {
          console.log('up-out')
          vars.mmf = null
          if (vars.mmef) {
            vars.mmef(mm)
            vars.mmef = null
          }
        })

        ctrl._init_scale_center()

        ctrl._init_done = true
        ctrl.update()
      }

      ctrl._init_scale_center = function() {
        if (this._init_scale_center_done) {return}

        // page.page_ctrl
        const g = new Graphics()
        this.scale_center = g
        g.setParent(page.page_ctrl)
        g.lineStyle(1, 0x0088aa, 1)
        g.beginFill(0x00ffff).drawRect(-10,-10,20,20).endFill()
        g.interactive = true
        // g.hitArea = new Rectangle(-100,-100,200,200)
        g.cursor = 'move'
        // g.on('pointerdown', e => {
        //   e.stopPropagation()
        //   console.log('s_down')
        // })

        // const h_center = new Graphics()

        this._init_scale_center_done = true
      }

      ctrl._init_scale_head = function() {
        if (this._init_scale_head_done) {return}
        if (guide.len() < 2) {return}

        const g = new Graphics()
        this.scale_head = g
        g.setParent(page.page_ctrl)
        g.beginFill(0x00ffff).drawRect(-10,-10,20,20).endFill()
        g.interactive = true
        g.cursor = 'move'

        this._init_scale_head_done = true
        // this._update_scale_head()

        return true
      }

      ctrl._update_scale_head = function() {
        if (!this._init_scale_head_done) {
          if (!this._init_scale_head()) {return}
        }
        this.scale_head.x = Math.min(
          page.width()/2 + 50,
          app.screen.width - page.pos.x - 50,
        )
        const g1 = guide.min(0).value
        const g2 = guide.min(1).value
        const top = (g1 + g2) / 2
        const between_two_guides_y = page.height() * (top - 0.5)
        this.scale_head.y = between_two_guides_y
      }

      ctrl._update_scale_center = function() {
        this.scale_center.x = Math.min(
          page.width()/2 + 50,
          app.screen.width - page.pos.x - 50,
        )
      }

      ctrl._update_scale_img = function() {

      }

      ctrl._init_scale_img = function() {

      }

      ctrl.update = function() {
        if (!this._init_done) {return}
        this._update_scale_center()
        this._update_scale_head()
      }

      return ctrl
    })()










    const ports_divs = document.querySelectorAll('.roster .port')
    const src_list = []
    ports_divs.forEach(el => {
      const src = el.querySelector('img[data-src]').dataset.src
      src_list.push(src)
    })

    page('102mm', '152mm')
    ctrl()
    guide(0.11)
    guide(0.44)
    imgs(src_list)
    layer(imgs.first()).show()
    layer().move(-100, -200).scale(0.5)

    stage.on('pointerdown', e => {
      console.log('stage.down')
      /*
        pos' = pos + (m' - m) / z
        pos' = m'/z + pos - m/z
        delta = pos - m/z
        pos' = delta + m'/z

        const k = 1 / page.zoom()
        const delta = pdif(layer().pos(), pmul(k, e.global))

        layer().pos(e => {
          return padd(delta, pmul(k, e.global))
        })
      */

      // const k = 1 / page.zoom()
      // const delta = pdif(layer().pos(), pmul(k, e.global))
      // layer().pos(mm => padd(delta, pmul(k, mm.global)))

      const pos = layer().pos()
      const init_pos = {x:pos.x, y:pos.y}
      const local_space = layer()._img.spr.parent
      const init_m_local = local_space.toLocal(e.global)

      layer().pos(mm => {
        return padd(init_pos, pdif(local_space.toLocal(mm.global), init_m_local))
      })

      // const init_pos = pos.clone((...args)=>{console.log('pos.cb', args)})
      // const lay = layer()
      // const spr = lay._img.spr
      // vars.mmf = mm => {
      //   // math-extras needed:
      //   init_pos.add(pdif(local_space.toLocal(mm.global), init_m_local), spr.position)
      // }
    })

    // ctrl('stage').down = e => {

    //   const lay = layer()
    //   const k = 1 / page.zoom()

    //   const delta = pdif(lay.pos(), pmul(k, e.global))

    //   ctrl('stage').move = e => {
    //     lay.pos(padd(delta, pmul(k, e.global)))
    //   }

    //   ctrl('stage').up = e => {

    //   }

    // }
    // key('.', () => {
    //   imgs.cur().save('kadr')
    //   layer('trg').hide()
    //   layer('trg', imgs.next()).show()
    // })
    // key(',', () => {
    //   imgs.cur().save('kadr')
    //   layer(imgs.cur()).hide()
    //   layer(imgs.prev()).show()
    // })
    // key('meta', () => {
    //   vars('scale', true)
    //   ctrl().mode('scale')
    // }, () => {
    //   vars('scale', false)
    //   ctrl().mode()
    // })
    // ctrl().mouse(()=>{
    //   vars('mouse', true)
    //   if (vars('scale')) {return}
    //   ctrl().mode('drag')
    // }, () => {
    //   vars('mouse', false)
    //   if (vars('scale')) {return}
    //   ctrl().mode()
    // })


    /*
    const doc = [
      {n:'cont', p: }
    ]

    const doc = [
      {n: 'cont', pos: [workspace_w/2, workspace_h/2], scale: zoom, has: [
        {n: 'ghost', alpha: 0.1},
        {n: 'page', has: [
          {n: 'mask', t: 'G', rect: [0xff, -width_px/2,-height_px/2,width_px,height_px], mask: true},
          {n: 'white', t: 'G', rect: [0xffffff, -width_px/2-10,-height_px/2-10,width_px+20,height_px+20]},
        ]},
      ]},
      {n: 'center', t:'G', circ: [0x00ffff, workspace_w/2,workspace_h/2,4]},
      {n: 'guide1', t:'G', pos: [0, cont.y + cont.height * (guideline1 - 0.5)], line: [1, 0x00ffff, .5, workspace_w, 0]}
    ]
    */

    /*
    // zoommed and dragged around
    const cont = new Container()
    cont.setParent(stage)
    cont.position.set(workspace_w/2, workspace_h/2)
    cont.scale.set(zoom)

    // unmasked/faded part outside
    const ghost = new Container()
    ghost.setParent(cont)
    ghost.alpha = 0.1

    // masked/clipped content of page
    const page = new Container()
    page.setParent(cont)

    const mask = new Graphics()
    mask.setParent(page)
    mask.beginFill(0xff0000).drawRect(-width_px/2,-height_px/2,width_px,height_px).endFill()
    page.mask = mask

    const white = new Graphics()
    white.setParent(page)
    white.beginFill(0xffffff).drawRect(-width_px/2-10,-height_px/2-10,width_px+20,height_px+20).endFill()

    const page_center = new Graphics()
    page_center.setParent(stage)
    page_center.visible = false
    page_center.beginFill(0x00ffff).drawCircle(workspace_w/2,workspace_h/2,4).endFill()

    const guide1 = new Graphics()
    guide1.setParent(stage)
    guide1.lineStyle(1, 0x00ffff, .5).lineTo(workspace_w, 0)
    guide1.y = cont.y + cont.height * (guideline1 - 0.5)

    const guide2 = new Graphics()
    guide2.setParent(stage)
    guide2.lineStyle(1, 0x00ffff, .5).lineTo(workspace_w, 0)
    guide2.y = cont.y + cont.height * (guideline2 - 0.5)

    const total_ctrl = new Container()
    total_ctrl.setParent(stage)
    total_ctrl.interactive = true
    total_ctrl.cursor = 'move'
    total_ctrl.hitArea = new Rectangle(0,0,workspace_w,workspace_h)
    total_ctrl.on('pointerdown', onMouseDown)

    const total_scale_cont = new Container()
    total_scale_cont.setParent(stage)
    total_scale_cont.x = workspace_w / 2
    total_scale_cont.y = workspace_h - 25

    const total_scale = new Graphics()
    total_scale.setParent(total_scale_cont)
    total_scale.interactive = true
    total_scale.beginFill(0x00ffff).drawCircle(0, 0, 10)
    total_scale.on('pointerdown', onMouseDown)



    // Sprites Storage
    const textures = {}
    const sprites = {}
    const kadr = {}
    let cur_src = false
    let cur_spr = false
    let cur_spr2 = false
    let last_x = 0
    let last_y = 0
    let last_scale = 0.5

    const getTex = src => {
      if (src in textures) {
        // return textures[src]
        return Promise.resolve(textures[src])
      }
      // textures[src] = Texture.from(src)
      // return textures[src]
      return loader.load(src).then(tex=>{
        textures[src] = tex
        return tex
      })
    }

    const getSpr = (src, inst=1) => {
      const sprites_key = src + inst
      if (sprites_key in sprites) {
        // return sprites[sprites_key]
        return Promise.resolve(sprites[sprites_key])
      }
      // const tex = getTex(src)
      // const spr = sprites[sprites_key] = new Sprite(tex)
      // return spr
      return getTex(src).then(tex => {
        const spr = new Sprite(tex)
        sprites[sprites_key] = spr
        spr.anchor.set(0.5)
        return spr
      })
    }

    const setKadrPos = (src, pos) => {
      if (!(src in kadr)) {kadr[src] = {}}
      if (!('pos' in kadr[src])) {kadr[src].pos = {}}
      kadr[src].pos.x = pos.x
      kadr[src].pos.y = pos.y
      last_x = pos.x
      last_y = pos.y
    }

    const getKadrPos = (src) => {
      if (!(src in kadr)) {return {x:last_x,y:last_y}}
      if (!('pos' in kadr[src])) {return {x:last_x,y:last_y}}
      return kadr[src].pos
    }

    const setKadrScale = (src, val) => {
      if (!(src in kadr)) {kadr[src] = {}}
      kadr[src].scale = val
      last_scale = val
    }

    const getKadrScale = (src) => {
      if (!(src in kadr)) {return last_scale}
      if (!('scale' in kadr[src])) {return last_scale}
      return kadr[src].scale
    }

    const setCurSpr = src => {
      if (cur_src == src) {
        return
      }
      if (cur_src) {
        cur_src = false
      }
      if (cur_spr) {
        cur_spr.removeFromParent()
        cur_spr = false
      }
      if (cur_spr2) {
        cur_spr2.removeFromParent()
        cur_spr2 = false
      }
      // move.clear()
      // scale.clear()

      cur_src = src

      getSpr(src).then(spr => {
        cur_spr = spr
        spr.scale.set(getKadrScale(src))
        spr.position.copyFrom(getKadrPos(src))
        spr.setParent(page)

        // const w = spr.width*zoom
        // const h = spr.height*zoom

        // move.lineStyle(1,0x00ffff).drawRect(-w/2, -h/2, w, h)
        // move.hitArea = new Rectangle(-w/2, -h/2, w, h)
        // ctrl.position.set(spr.x*zoom, spr.y*zoom)

        // scale.beginFill(0x00ffff).drawRect(-6, -6, 12, 12).endFill()
        // scale.x = w/2
        // scale.y = 0
        // scale.hitArea = new Rectangle(-6,-6,12,12)

        getSpr(src, 2).then(spr2 => {
          cur_spr2 = spr2
          spr2.scale.set(spr.scale.x)
          spr2.position.copyFrom(spr)
          spr2.setParent(ghost)
        })
      })
    }

    // Interaction
    function port_click(e) {
      const img = e.target.querySelector('img[data-src]')
      if (!img) {return}
      setCurSpr(img.dataset.src)
    }
    const ports = document.querySelectorAll('.roster .port')
    ports.forEach(port => {port.addEventListener('click', port_click)})
    if (!cur_src) {setCurSpr(ports[0].querySelector('img[data-src]').dataset.src)}

    // Keyboard
    let scaleMode = false
    let mouseMode = null // null | move | scale
    let mouseDown = false
    const setMouseMode = value => {
      if        (mouseMode ===  null  && value === 'move') {
        startFreeDrag(mouse_move_event)
      }
      else if   (mouseMode ===  null  && value === 'scale') {
        startFreeScale(mouse_move_event)
      }
      else if   (mouseMode === 'move' && value === null) {
        move_func = null
        if (onMoveEnd) {
          onMoveEnd()
          onMoveEnd = null
        }
      }
      else if   (mouseMode === 'move' && value === 'scale') {
        if (onMoveEnd) {
          onMoveEnd()
          onMoveEnd = null
        }
        startFreeScale(mouse_move_event)
      }
      else if   (mouseMode === 'scale' && value === null) {
        move_func = null
        if (onMoveEnd) {
          onMoveEnd()
          onMoveEnd = null
        }
      }
      else if   (mouseMode === 'scale' && value === 'move') {
        if (onMoveEnd) {
          onMoveEnd()
          onMoveEnd = null
        }
        startFreeDrag(mouse_move_event)
      }

      mouseMode = value
    }

    const metaKey = keyboard('MetaLeft')

    metaKey.press = e => {
      console.log('metaKey.press', e)
    }

    metaKey.release = e => {
      console.log('metaKey.release', e)
    }

    */


    /*
    window.addEventListener('keydown', ev => {
      // ev.preventDefault()
      console.log('document key', ev)
      if (cur_spr) {
        let d = 10
        if (ev.shiftKey) {d = 50}
        else if (ev.altKey) {d = 1}

        if (ev.code == 'MetaLeft' || ev.code == 'MetaRight') {
          setMouseMode('scale')
          // mouseMode = 'scale'
          scaleMode = true
          page_center.visible = true
          total_scale_cont.visible = false
          // if (mouse_move_event) {
          //   if (onMoveEnd) {onMoveEnd(mouse_move_event)}
          //   startFreeScale(mouse_move_event)
          // }
        } else if (ev.code == 'ArrowDown') {
          cur_spr.y += d
          cur_spr2.y += d
          // move.y += d*zoom
        } else if (ev.code == 'ArrowUp') {
          cur_spr.y -= d
          cur_spr2.y -= d
          // move.y -= d*zoom
        } else if (ev.code == 'ArrowRight') {
          cur_spr.x += d
          cur_spr2.x += d
          // move.x += d*zoom
        } else if (ev.code == 'ArrowLeft') {
          cur_spr.x -= d
          cur_spr2.x -= d
          // move.x -= d*zoom
        } else if (ev.code == 'Period') {
          const arr = Array.from(ports)
          const cur_index = arr.findIndex(i => i.dataset.src == cur_src)
          if (cur_index > -1) {
            setCurSpr(arr[lim(0, arr.length-1, cur_index+1)].dataset.src)
          }
        } else if (ev.code == 'Comma') {
          const arr = Array.from(ports)
          const cur_index = arr.findIndex(i => i.dataset.src == cur_src)
          if (cur_index > -1) {
            setCurSpr(arr[lim(0, arr.length-1, cur_index-1)].dataset.src)
          }
        }
      } else {
        console.log('no cur_spr')
      }
    })
    window.addEventListener('keyup', ev => {
      // console.log(ev.code, 'up')
      if (ev.code == 'MetaLeft' || 'MetaRight') {
        scaleMode = false
        page_center.visible = false
        total_scale_cont.visible = true
        // stageMouseUp(mouse_move_event)
        if (mouseDown) {setMouseMode('move')}
        else {setMouseMode(null)}
      }
    })
    */


    /*
    // Mouse
    stage.interactive = true
    stage.hitArea = new Rectangle(-window.screen.width, -window.screen.height, 2*window.screen.width, 2*window.screen.height)
    stage.on('pointerup', stageMouseUp)
    stage.on('pointerupoutside', stageMouseUp)
    let move_func = null
    let mouse_move_event = null

    stage.on('mousemove', e => {
      mouse_move_event = e
      if (move_func) {move_func(e)}
    })

    function stageMouseUp(e) {
      // stage.off('pointermove')
      mouseDown = false
      // move_func = null
      // if (onMoveEnd) {
      //   onMoveEnd(e)
      //   onMoveEnd = null
      // }
      // setMouseMode(null)
      if (scaleMode) {}
      else {setMouseMode(null)}
    }

    function getStyleWidth() {
      return cur_spr.width / mask.width * 100 + '%'
    }

    function getStyleLeft() {
      return (-cur_spr.width/2 + mask.width/2 + cur_spr.x)/mask.width * 100 + '%'
    }

    function getStyleTop() {
      return (-cur_spr.height/2 + mask.height/2 + cur_spr.y)/mask.height * 100 + '%'
    }



    // TMP vars
    let onMoveEnd = null



    // Hendlers

    function onMouseDown(event) {



      if (scaleMode) {
        const x0 = e.global.x
        // const glob = total_scale_cont.toGlobal(new Point(0,0))
        // const d0 = Math.hypot(e.global.x - glob.x, e.global.y - glob.y)
        const s0 = cur_spr.scale.x
        stage.on('pointermove', e2 => {
          // const d1 = Math.hypot(e2.global.x - glob.x, e2.global.y - glob.y)
          // const d = d1/d0
          const d = e2.global.x - x0
          total_scale.x = d
          cur_spr.scale.set(s0 * (1 + d/workspace_w))
          cur_spr2.scale.set(cur_spr.scale.x)
        })
        onMoveEnd = e => {
          total_scale.x = 0
          setKadrScale(cur_src, cur_spr.scale.x)
        }
      }
    }

    function onMouseUp(event) {

    }

    */

    /*

    const startFreeScale = mouse_event => {
      const d = dist(mouse_event.global, cont.position)
      const s = cur_spr.scale.x
      const k = s / d
      const p = pdiv(cur_spr.position, d)

        // scale  - dist   |
        // scale' - dist'  | => scale' = scale * dist' / dist
        // anchor pos  - dist   |
        // anchor pos' - dist'  | => anchor pos' = anchor pos * dist' / dist

      move_func = e => {
        const d1 = dist(e.global, cont.position)
        cur_spr.scale.set(k * d1)
        cur_spr2.scale.set(cur_spr.scale.x)
        cur_spr.position.copyFrom(pmul(d1, p))
        cur_spr2.position.copyFrom(cur_spr.position)
      }
      onMoveEnd = e => {
        setKadrScale(cur_src, cur_spr.scale.x)
        setKadrPos(cur_src, cur_spr.position)
      }
    }

    const startFreeDrag = e => {
      const delta = pdif(cur_spr.position, pdiv(e.global, zoom))
      move_func = e => {
        cur_spr.position.copyFrom(padd(delta, pdiv(e.global, zoom)))
        cur_spr2.position.copyFrom(cur_spr.position)
      }
      onMoveEnd = e => {
        setKadrPos(cur_src, cur_spr.position)
      }
    }

    */


  </script>
{% endblock js %}
